# 131. 分割回文串

刚开始有一点点思路，但是总是做不出来。

难在如何“连续取回文串”和“分割回文串上”。

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;

    bool isPalindrome(const string& str, int start, int end) {
        // [start, end]
        for (int i = start, j = end; i < j; i++, j--) {
            if (str[i] != str[j]) {
                return false;
            }
        }
        return true;
    }

    void backTracking(string& s, int start) {
        if (start >= s.length()) {
            res.push_back(path);
            return;
        }
        for (int i = start; i < s.length(); i++) {
            if (isPalindrome(s, start, i)) {
                string subs = s.substr(start, i - start + 1);
                path.push_back(subs);
                backTracking(s, i + 1);  // 寻找i+1为起始位置的子串
                path.pop_back();
            }
        }
        return;
    }


    vector<vector<string>> partition(string s) {
        backTracking(s, 0);
        return res;
    }
};
```

文章讲解中，这个`for`循环表示“连续取”的环节，如果取到回文串，那就进行分割
```c++
for (int i = start; i < s.length(); i++) {
    ...
}
```

取回文串的下一个字符为起点，递归查找。
```c++
backTracking(s, i + 1);  // 寻找i+1为起始位置的子串
```