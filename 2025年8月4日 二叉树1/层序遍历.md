# 二叉树层序遍历

目前已做
102

107

199

637

429

515

## 116. 填充每个节点的下一个右侧节点指针
最开始我是用bfs做的
```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (root == NULL) return root;
        queue<Node*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; ++i) {
                Node* check = que.front();
                que.pop();
                // if (i == 0) check->next = NULL;
                if (i < size - 1) que.front()->next = check;
                if (check->right) que.push(check->right);
                if (check->left) que.push(check->left);
            }
        }
        return root;
    }
};
```

bfs的思路很直观也很简单，后面我尝试进阶做法。

我是看了题解重新写了一遍，和题解有稍微不同。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        Node* leftmost = root;
        while (leftmost != NULL) {  // 1*
            Node* check = leftmost;
            while (check != NULL && check->left) {  // 2*
                check->left->next = check->right;
                if (check->next) check->right->next = check->next->left;
                check = check->next;
            }
            leftmost = leftmost->left;
        }
        return root;
    }
};
```

和题解的不同之处为注释处语句
1. `while (leftmost != NULL)`，题解为`while (leftmost->left != NULL)`，题解的思路是在第$N-1$层去处理第$N$层的节点，所以用题解的`while`是符合这个思路的。但是像我这样写的话，可以把`root == NULL`的情形包括进去，就不用再在开头对`root`是否为空进行判断。

2. 这里和`1*`是相关联的，只检查`check != NULL`或者`check->left`都不行，必须同时检查
    - `check != NULL`，`check`可能是最底层的节点，`check->left->next`会报错
    - `check->left`，当`check == NULL`时，`check->left->next`也会报错

# 117. 填充每个节点的下一个右侧节点指针 II

原本是照着116. 题改的答案，但是改出来是一堆屎山，也没办法通过。

后来去研究了第二热门的题解，发现了新世界。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (root == NULL) return root;
        Node dummyHead;
        Node* most = root;
        while (most != NULL) {
            dummyHead.next = NULL;
            Node* check = &dummyHead;
            while (most != NULL) {
                if (most->left) {
                    check->next = most->left;
                    check = check->next;
                }
                if (most->right) {
                    check->next = most->right;
                    check = check->next;
                }
                most = most->next;
            }
            most = dummyHead.next;
        }
        return root;
    }
};
```

这里用了一个虚拟头节点，用来把第$N$层的所有节点串联起来，厉害之处在于处理$N+1$层的时候，可以取`dummyHead.next`作为最左边的节点。

如果没看题解，我绞尽脑汁也想不出来解法。

104 easy