# 144. 二叉树的前序遍历

非常easy的一道题
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void helper(TreeNode* root, vector<int>& vec) {
        if (root == nullptr) {
            ;
        } else {
            vec.push_back(root->val);
            helper(root->left, vec);
            helper(root->right, vec);
        }
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        helper(root, res);
        return res;
    }
};
```

# 145. 二叉树的后序遍历

还是很简单的一道题
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void helper(TreeNode* root, vector<int>& vec) {
        if (root == nullptr) return;
        helper(root->left, vec);
        helper(root->right, vec);
        vec.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        helper(root, res);
        return res;
    }
};
```

# 94. 二叉树的中序遍历

依旧easy（没有接受迭代法的拷打）

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void helper(TreeNode* root, vector<int>& vec) {
        if (root == nullptr) return;
        helper(root->left, vec);
        vec.push_back(root->val);
        helper(root->right, vec);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        helper(root, res);
        return res;
    }
};
```

# 94. 二叉树的中序遍历

还是看的文章讲解。

我最开始的思路还是像前序遍历一样，把每层的节点入栈，但实际上并不可行。

我也想到是先一直往左子节点遍历和入栈，直到遍历到第一个空节点，开始出栈。但是想不到应该如何实现。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        TreeNode* check = root;
        stack<TreeNode*> stackTree;
        // 如果一开始check == nullptr，那就说明二叉树为空，不进行循环
        while (check != nullptr || !stackTree.empty()) {
            if (check) {
                stackTree.push(check);
                check = check->left;
            } else {
                check = stackTree.top();
                res.push_back(stackTree.top()->val);
                stackTree.pop();
                check = check->right;
            }
        }
        return res;
    }
};
```