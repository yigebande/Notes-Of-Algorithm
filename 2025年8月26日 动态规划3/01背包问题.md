# 01背包问题
## 思路
### 物品数量为M，背包容量为N，构建一个大小为$M \times (N + 1)$的`dp`数组

![](images/01Knapsack%20problem.svg)

### 先考虑一般情况
1. 对于`dp[i][j]`，`i`代表当前所要选择的物品编号，`j`表示当前的背包容量。
2. 如果当前背包容量`j`小于第`i`个物品的大小，那么无法把第`i`个物品放进背包，那么`dp[i][j]`继承`dp[i - 1][j]`的情况，也就是在`dp[i][j]`正上方的状态，关于第`i - 1`个物品的选取。
3. 如果当前背包容量`j`大于或等于第`i`个物品的大小，那么比较**不选当前物品**和**选择当前物品**分别所得利益，取较大值。
    + 不选当前物品，即继承`dp[i - 1][j]`的状态，利益为`dp[i - 1][j]`。
    + 选择当前物品，背包剩余容量为`j - weight[i]`，利益为`dp[i - 1][j - weight[i]] + value[i]`。

### `dp`数组的初始化
对第一行的元素进行操作，从背包容量为`weight[0]`的背包开始往后遍历，所有的局部最优解都是`value[0]`。
```c++
for (int j = weight[0]; j <= N; j++) {
    dp[0][j] = value[0];
}
```

### 最终结果
即`dp[M - 1][N]`

上面的思路是根据二维`dp`来做的，其实可以把`dp`压缩成一维。

## 一维`dp`
和二维`dp`稍微有些不同，对于一般情况，一维`dp`的遍历方式是从后往前遍历

以[卡码网46题](https://kamacoder.com/problempage.php?pid=1046)为例

```c++
#include <bits/stdc++.h>
using namespace std;

int M, N;

int main() { 
    cin >> M >> N;
    vector<int> dp(N + 1, 0);
    vector<int> space(M, 0);
    vector<int> value(M, 0);
    for (int i = 0; i < M; i++) {
        cin >> space[i];
    }
    for (int i = 0; i < M; i++) {
        cin >> value[i];
    }
    for (int i = space[0]; i <= N; i++) {
        dp[i] = value[0];
    }
    // 注意，这里的i是从1开始而不能从0开始，从0开始的话会导致结果变大，因为会多加一次value[0]
    for (int i = 1; i < M; i++) {
        for (int j = N; j >= space[i]; j--) {
        dp[j] = max(dp[j], dp[j - space[i]] + value[i]);
        }
    }
    cout << dp[N] << endl;
    return 0; 
}
```