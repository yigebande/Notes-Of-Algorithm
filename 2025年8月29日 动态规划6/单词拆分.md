# 139. 单词拆分
查了很多资料，cppreference，CSDN，知乎，学了很多字符串操作，在平板上模拟了好久，终于，第一次，靠自己做出了一道很难的动态规划题目！！！

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<int> dp(s.size() + 1, 0);
        dp[0] = 1;
        // i表示当前子串长度
        for (int i = 0; i <= s.size(); i++) {
            bool flag = 0;
            string sub = s.substr(0, i);
            for (int j = 0; j < wordDict.size(); j++) {
                if (i >= wordDict[j].length()) {
                    string subSub = sub.substr(sub.length() - wordDict[j].length());
                    if (subSub == wordDict[j] && dp[i - wordDict[j].length()]) {
                            dp[i] = 1;
                            break;
                    }
                }  
            }
        }
        return dp[s.size()];
    }
};
```

## 思路
### 递推
1. 不断从`s`的第0位，取子串`sub`，其长度为`i`
2. 检查`sub`从末尾开始的和`wordDict[j]`一样长的子串，即`subSub`，如果`subSub`和`wordDict[j]`相等，那么检查除了`subSub`的前面一条`sub`的子串（题目保证`wordDict`中不会出现重复元素）

### 初始化
`dp[0] = 1`，即空字符串肯定可以由`wordDict`里的元素组成（所有元素都不选就行）

### `dp`数组下标含义
意为从`s`第0为开始，长度为`i`的子串能否用`wordDict`中的元素来组成，如果可以，`dp[i] == 1`，否则`dp[i] == 0`。