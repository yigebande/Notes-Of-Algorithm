# 516. 最长回文子序列

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.length() + 1, vector<int>(s.length() + 1, 0));
        for (int i = 1; i <= s.length(); i++) {
            dp[i][i] = 1;
        }
        for (int i = s.length(); i >= 1; i--) {
            for (int j = i + 1; j <= s.length(); j++) {
                if (s[i - 1] == s[j - 1]) {
                    // dp[i][j] = max({dp[i + 1][j - 1] + 2, dp[i + 1][j], dp[i][j - 1]});
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        };
        return dp[1][s.length()];
    }
};
```

## 思路
文章讲解里面讲的很清楚了

1. `dp`下标含义
    `dp[i][j]`表示字符串范围为[i - 1, j - 1]的最长回文序列长度

2. 递推公式
    - 如果`s[i - 1] == s[j - 1]`，则有`dp[i][j] = dp[i + 1][j - 1] + 2`
    - 如果`s[i - 1] != s[j - 1]`，那么说明`s[i - 1]`和`s[j - 1]`的同时加入并不能给`s[i: j-2]`贡献更多的回文序列长度，所以查看分别加入`s[i - 1]`和`s[j - 1]`的情况，取较大值，也就是`dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])`

    为什么不检查`dp[i + 1][j - 1]`？因为对`dp[i + 1][j], dp[i][j - 1]`分别进行检查的时候都考虑过了`dp[i + 1][j - 1]`和各自的另外一个值的大小，所以这里`dp[i + 1][j], dp[i][j - 1] >= dp[i + 1][j - 1]`，不用进行重复检查。

3. 遍历顺序
    因为要用到`dp[i + 1][j], dp[i][j - 1]`，所以遍历顺序为从下往上，从左往右

## 终于
结束了动态规划

2025年9月7日