# 647. 回文子串
用Excel画了一下表格，没想到一下子就做出来了

```c++
class Solution {
public:
    int countSubstrings(string s) {
        if (s.length() == 1) return 1;
        vector<vector<int>> dp(s.length() + 1, vector<int>(s.length() + 1, 0));
        // 初始化对角线
        for (int i = 1; i <= s.length(); i++) {
            dp[i][i] = 1;
        }
        int sum = s.length();
        for (int i = s.length(); i >= 1; i--) {
            for (int j = s.length(); j > i; j--) {
                if (s[i - 1] == s[j - 1]) {
                    if (i + 1 == j || dp[i + 1][j - 1] == 1) {
                        dp[i][j] = 1;
                    }
                    sum += dp[i][j];
                }
            }
        }
        return sum;
    }
};
```

## 思路
1. `dp`下标含义
    `dp[i][j]`表示从第`i - 1`开始到`j - 1`为止的闭区间的s的子串是否为回文字符串，如果是，`dp[i][j] = 1`，否则为0
2. 递推公式
    如果`s[i - 1] != s[j - 1]`，那么这个子串不可能是回文串。

    如果`s[i - 1] == s[j - 1]`，那么检查`s[i: j-2]`是否为回文字符串，即检查`dp[i + 1][j - 1]`是否为1，如果为1，说明`s[i: j-2]`也是回文字符串，所以`s[i-1: j-1]`也是回文字符串，有`dp[i][j] = 1`；又或者是检查`s[i - 1]`和`s[j - 1]`是否为相邻的字符，如果是，则直接令`dp[i][j] = 1`。

3. 遍历方向
    由于要用到`dp[i + 1][j - 1]`，应该从下往上遍历，至于`j`，从左往右或者从右往左都可以。

4. 初始化
    初始化对角线即可，因为对角线代表的是单个字符，肯定是回文子串；其他为0。
