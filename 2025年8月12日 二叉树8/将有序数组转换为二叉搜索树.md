# 108. 将有序数组转换为二叉搜索树

之前有做到类似的题目，用一个函数来接收一个`vector`和开始的索引和结束的索引，我这里用的是左闭右开区间。

由于数据量的大小不会超过`int`的最大值，所以我就没有做防溢出处理。

但是实际上我没有考虑到自己构建的二叉搜索树是否平衡。

文章讲解给出了这样的解释：
> 其实数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。**所以想构成不平衡的二叉树是自找麻烦。**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // [head, tail)
    TreeNode* constructBST(vector<int>& nums, int head, int tail) {
        if (head >= tail) return nullptr;
        if (head + 1 == tail) {
            return new TreeNode(nums[head]);
        }
        int mid = (head + tail) >> 1;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = constructBST(nums, head, mid);
        root->right = constructBST(nums, mid + 1, tail);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* result = constructBST(nums, 0, nums.size());
        return result;
    }
};
```