# 452. 用最少数量的箭引爆气球

刚开始没有什么思路，已经打算看文章讲解了的。

但是看了一下评论，发现有的人说其实是很简单的题目，只是求交集就行，然后我试着做了一下，有点误打误撞的成分。

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] > b[0];
    }

    bool findIn(vector<int>& res, vector<int>& a) {
        if (res[1] < a[0] || res[0] > a[1]) {
            return false;
        }
        res[0] = max(res[0], a[0]);
        res[1] = min(res[1], a[1]);
        return true;
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int sum = 0;
        vector<int> res(2, -1);
        for (int i = 0; i < points.size(); i++) {
            if (i == 0 || findIn(res, points[i]) == false) {
                res[0] = points[i][0];
                res[1] = points[i][1];
                sum++;
            }
        }
        return sum;
    }
};
```

1. 首先要对`points`进行排序，以便逐个检查的时候查找交集。
```c++
static bool cmp(vector<int>& a, vector<int>& b) {
    return a[0] > b[0];
}

sort(points.begin(), points.end(), cmp);
```

2. 实现查找两个`vector`的交集的函数`findIn`
```c++
/* res是前面存在交集的vector的交集（这句话有点拗口）
 * a是当前要检查的vector
 */
bool findIn(vector<int>& res, vector<int>& a) {
    // 如果两者没有交集，返回false
    if (res[1] < a[0] || res[0] > a[1]) {
        return false;
    }
    // 如果两者有交集，那么更新res，让res为res和a的交集
    res[0] = max(res[0], a[0]);
    res[1] = min(res[1], a[1]);
    return true;
}
```

3. 关于这个循环，我刚开始觉得要分离`i == 0`和`findIn(res, points[i])`的情况，但是这样做的话，如果全部的气球都有交集，不知道是否要在循环外进行一次射击

然后我就想着刚进入循环的时候先射一发，如果下一个气球和当前气球有交集，那么这颗子弹会穿透当前气球，打破下一个气球，直到没有交集。若还有气球没打完，继续发射子弹。

`findIn`函数的好处在于既能作为`if`语句的判断条件，又能更新交集状态
```c++
for (int i = 0; i < points.size(); i++) {
    if (i == 0 || findIn(res, points[i]) == false) {
        res[0] = points[i][0];
        res[1] = points[i][1];
        sum++;
    }
}
```

最终代码还能改成这样，用`points[0]`给`res`初始化，然后循环中无交集出现的时候的更新并入到`findIn`中。
```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] > b[0];
    }

    bool findIn(vector<int>& res, vector<int>& a) {
        if (res[1] < a[0] || res[0] > a[1]) {
            res[0] = a[0];
            res[1] = a[1];
            return false;
        }
        res[0] = max(res[0], a[0]);
        res[1] = min(res[1], a[1]);
        return true;
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int sum = 0;
        vector<int> res{points[0][0], points[0][1]};
        for (int i = 0; i < points.size(); i++) {
            if (i == 0 || findIn(res, points[i]) == false) {
                sum++;
            }
        }
        return sum;
    }
};
```