# 110. 平衡二叉树

最开始没看清楚题目要求，以为只是根节点的两棵子树的深度差小于等于1就行，但是很快就卡在了这个测试用例。

![](images/tree1.svg)

后面我才看清楚题目要求，是每个节点的子树都要判断一次高度差。

我用了一些投机取巧的方法，但是并不能通过测试。

所以直接去看了文章讲解。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getHeight(TreeNode* root) {
        if (root == nullptr) return 0;
        int leftHeight = getHeight(root->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(root->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }

    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

一开始不太明白为什么如果给出的二叉树不是平衡二叉树时，`isBalanced`中的`getHeight`一定会返回-1，因为我做过CS106B中的一些assignments，里面有一些要求用回溯来做的题目。那些函数和这里的`getHeight`有点类似，都是满足某些条件就继续往下搜索，并且高度要+1，否则就高度就-1，和先前的+1相抵消。在某些很有规律的情形下，最终的返回值是一个定值。

后来我动手画了图发现，其实早在这里就已经做了处理
```c++
int leftHeight = getHeight(root->left);
if (leftHeight == -1) return -1;
int rightHeight = getHeight(root->right);
if (rightHeight == -1) return -1;
```

这里的意思是说，如果当前节点的子树不是平衡二叉树，那么没有必要再去检查这棵树的高度了，直接返回-1就行。

只要有一棵子树不是平衡二叉树，那么整棵二叉树就不是平衡二叉树。