# 121. 买卖股票的最佳时机
虽然leetcode上面写着这是 **简单题**，但是我还是想了好久。

然后看到下面通过率为59.1%，我顿时觉得这可能是一道难题。

因为之前用贪心做过122. 买卖股票的最佳时机II，做这道题有点受到那道题的干扰。
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 1) return 0;
        int res = 0;
        int minimum = prices[0];
        for (int i = 1; i < prices.size(); i++) {
            // 最大值要么是当前检查的元素减去最小值，即第i天卖掉股票
            // 要么在之前已经卖掉股票，而且总收益比在今天才卖掉股票更高
            // 在股票价值为minimum的时候买入
            // 不存在比minimum大的数，使得prices[i]减去这个数比prices[i]减去minimum得到的值更大
            res = max(res, prices[i] - minimum);
            minimum = min(minimum, prices[i]);
        }
        return res;
    }
};
```

## 思路
我刚开始用的暴力去做，然后发现超时了。

我就思考到底哪里可以用到动态规划。

后来灵光乍现，每往下遍历都检查一下已经遍历过的元素中的最小值，但是我最开始用的是
```c++
int findMin(vector<int>& prices, int end) {
    return *min_element(prices.begin(), prices.begin() + end);
}
```
很显然，这个也会导致超时。

后来又想到可以不断地用最小值`minimum`和当前正在检查的元素`prices[i]`作比较，不断取`minimum = min(minimum, prices[i])`。

这道题甚至不用额外申请空间作为`dp`数组，直接用一个变量就行。

## 动态规划思路
1. `dp`数组下标含义
    - `dp[i][0]`表示 **第i天持有股票所得最大现金**，可以为负数
    - `dp[i][1]`表示 **第i天不持有股票所得最大现金**
    - 注意，这里的 **持有** 和 **买入** 是有区别的，如果前一天的股票价格比今天便宜，那可能前一天就买入了，这里`dp[i][0]`的遍历过程中，负数的绝对值是逐渐变小的，最终可能会变成一个常值。但是这里 **持有** 表示 **已经买入或者刚好买入** 的意思。
    - 同理，**不持有** 和 **卖出** 也是有区别的，如果前一天的股票价格比今天的高，那么可能前一天就卖出去了。这里`dp[i][1]`在遍历过程中是逐渐变大的。但是 **不持有** 在这里是表示 **没有买也没有卖或者已经卖出或者正好卖出** 的意思。
2. 确定递推公式
    - `dp[i][0]`只能由`dp[i - 1][0]`递推得来，因为如果前一天不持有股票，那么说明这支股票已经被卖出。递推公式为：`dp[i][0] = max(dp[i - 1][0], -prices[i])`，比较前面的股票价格和当前的股票价格，选价格低的那个买入。
    - `dp[i][0]`可以由`dp[i - 1][0]`和`dp[i - 1][1]`递推得来。递推公式为：`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])`，比较前面不持有股票所获得的最大现金和第i天才把股票卖出的最大现金，取较大值。
3. 递推公式初始化
    - 第0天持有股票，所得现金为`-prices[1]`，即`dp[0][0] = prices[0]`。
    - 第0天不持有股票，可以理解为压根没买，所以`dp[0][1] = 0`。