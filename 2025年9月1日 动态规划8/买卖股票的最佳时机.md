# 121. 买卖股票的最佳时机
虽然leetcode上面写着这是 **简单题**，但是我还是想了好久。

然后看到下面通过率为59.1%，我顿时觉得这可能是一道难题。

因为之前用贪心做过122. 买卖股票的最佳时机II，做这道题有点受到那道题的干扰。
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 1) return 0;
        int res = 0;
        int minimum = prices[0];
        for (int i = 1; i < prices.size(); i++) {
            // 最大值要么是当前检查的元素减去最小值，即第i天卖掉股票
            // 要么在之前已经卖掉股票，而且总收益比在今天才卖掉股票更高
            // 在股票价值为minimum的时候买入
            // 不存在比minimum大的数，使得prices[i]减去这个数比prices[i]减去minimum得到的值更大
            res = max(res, prices[i] - minimum);
            minimum = min(minimum, prices[i]);
        }
        return res;
    }
};
```

## 思路
我刚开始用的暴力去做，然后发现超时了。

我就思考到底哪里可以用到动态规划。

后来灵光乍现，每往下遍历都检查一下已经遍历过的元素中的最小值，但是我最开始用的是
```c++
int findMin(vector<int>& prices, int end) {
    return *min_element(prices.begin(), prices.begin() + end);
}
```
很显然，这个也会导致超时。

后来又想到可以不断地用最小值`minimum`和当前正在检查的元素`prices[i]`作比较，不断取`minimum = min(minimum, prices[i])`。

这道题甚至不用额外申请空间作为`dp`数组，直接用一个变量就行。