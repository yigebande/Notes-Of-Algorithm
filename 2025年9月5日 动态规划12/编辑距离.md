# 72. 编辑距离

最开始我的思路是这样的
```c++
if (i == j) { // w1和w2的子串长度相等
    if (word1[i - 1] == word2[j - 1]) { // 新加入的字符相等，不用进行操作
        dp[i][j] = dp[i - 1][j - 1]; 
    } else { // 新加的字符不相等，进行替换操作
        dp[i][j] = dp[i - 1][j - 1] + 1;
    }
} else if (j > i) { // w1子串的长度小于w2子串的长度
    if (word1[i - 1] == word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]; // w1新加入的字符和w2的相等，不用进行操作
    } else { // w1新加入的字符和w2的不相等，对w1进行添加
        dp[i][j] = dp[i][j - 1] + 1;
    }
} else { // w1子串的长度大于w2子串的长度
    if (word1[i - 1] == word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]; // w1新加入的字符和w2的相等，不用进行操作
    } else { // w1新加入的字符和w2的不相等，对w1进行删除
        dp[i][j] = dp[i - 1][j] + 1;
    }
}
```

这种思路能通过大部分测试案例。

后来修改了很多，我一直卡在这个测试案例：

`word1 = "sea", word2 = "eat"`

我简单进行了一下模拟，发现问题出在
```c++
if (i == j) { // w1和w2的子串长度相等
    ...
     else { // 新加的字符不相等，进行替换操作
        dp[i][j] = dp[i - 1][j - 1] + 1;
    }
}
```

我当时想，如果两个字符串长度相等，而只是最后一个字符不相等的话，一定是`word1`和`word2`各自回退一个字符的修改操作数 加上 往`word1`中添加一个和新的`word2`的末尾字符相同的字符的操作 吗？

我观察了自己画的Excel表格后发现，如果从

`word1 = "sea", word2 = "ea", ===> word1_1 = "ea", opts = 1`

到

`word1 = "sea", word2 = "eat"`

即

`word1_1 = "ea" ===> "eat"`

只需要增加一个`'t'`就行了。

从`"sea"`变到`"eat"`，有下面三种方式：
1. `"sea" -> "ea" -> "eat"`，先让`word1`变成`word2`的一个子串，再往`word1`的末尾添加一个字符
2. `"sea" -> "set" -> "eat"`，先替换`word1`的最后一个字符，使其与`word2`最后一个字符相等，再修改前面的字符
3. `"sea" -> "se" -> "eat"`，先删除`word1`的最后一个字符，再将其转换到`word2`

这样看来，添加，替换，删除的操作都考虑到了，最后取操作数最小的操作。

## 动态规划思路
1. 数组下标含义
    `dp[i][j]`表示`word1[:i-1]`转换到`word2[:j-1]`所需要的最小的操作数。
2. 递推公式
    - 如果`word1[i - 1] == word[j - 1]`，不用进行修改，`dp[i][j] = dp[i - 1][j - 1]`
    - 否则，`dp[i][j] = min({dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1})`
3. 初始化
    由`word1`变到空字符串 和 由空字符串变到`word2`
    `for (int i = 1; i <= word1.size(); i++) dp[i][0] = i;`

    `for (int j = 1; j <= word2.size(); j++) dp[0][j] = j;`

## 代码
### 初始版本
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        // 初始化
        for (int i = 1; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 1; j <= word2.size(); j++) dp[0][j] = j;

        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (i == j) { // w1和w2的子串长度相等
                    if (word1[i - 1] == word2[j - 1]) { // 新加入的字符相等，不用进行操作
                        dp[i][j] = dp[i - 1][j - 1];
                    } else { // 新加的字符不相等，进行替换操作
                        dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1; 
                    }
                } else if (j > i) { // w1子串的长度小于w2子串的长度
                    if (word1[i - 1] == word2[j - 1]) { // w1新加入的字符和w2的相等，不用进行操作
                        dp[i][j] = dp[i - 1][j - 1];
                    } else { // w1新加入的字符和w2的不相等
                        // dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2);
                        // dp[i][j] = dp[i][j - 1] + 1;
                        dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1; 
                    }
                } else {
                    if (word1[i - 1] == word2[j - 1]) { // w1子串的长度大于w2子串的长度
                        dp[i][j] = dp[i - 1][j - 1]; // w1新加入的字符和w2的相等，不用进行操作
                    } else { // w1新加入的字符和w2的不相等，对w1进行删除
                        // dp[i][j] = min(dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1);
                        // dp[i][j] = dp[i - 1][j] + 1;
                        dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1; 
                    }
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 优化后的版本
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        // 初始化
        for (int i = 1; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 1; j <= word2.size(); j++) dp[0][j] = j;

        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```