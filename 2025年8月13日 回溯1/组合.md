# 77. 组合
最开始做的时候犯了很多错误。
```c++
class Solution {
public:
    void combination(int n, int k, vector<int>& vec, vector<vector<int>>& res) {
        if (n < k && n == 0) return;
        if (k == 1) {
            vec.push_back(n);
            res.push_back(vec);
            vec.pop_back();
            return;
        }
        for (int i = n; i >= 1; i--) {
            vec.push_back(i);
            combination(i - 1, k - 1, vec, res);
            vec.pop_back();
            combination(i - 1, k, vec, res);
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> vec;
        combination(n, k, vec, res);
        return res;
    }
};
```

问题首先出在
```c++
for (int i = n; i >= 1; i--) {
    vec.push_back(i);
    combination(i - 1, k - 1, vec, res);
    vec.pop_back();
    combination(i - 1, k, vec, res);
}
```

这属于是有点搞不清楚情况了。

我在CS61A和CS106B中都做过求组合的题目，学习了两种做法：
1. 选或不选
2. 遍历选取

如果是**选或不选**，那么不应该有循环，就是单纯的
```c++
vec.push_back(i);
// 选择了当前的元素，那么k-1
combination(i - 1, k - 1, vec, res);
vec.pop_back();
// 不选当前的元素，k不变
combination(i - 1, k, vec, res);
```

如果是**遍历选取**，应该如下
```c++
for (int i = n; i >= 1; i--) {
    vec.push_back(i);
    combination(i - 1, k - 1, vec, res);
    vec.pop_back();
}
```

`n == 4, k == 2`的情况下，先选了4，然后递归到`n == 3, k == 1`的情况，然后会有`[4, 3], [4, 2], [4, 1]`。

再然后是
```c++
if (k == 1) {
    vec.push_back(n);
    res.push_back(vec);
    vec.pop_back();
    return;
}
```

我原本想到的是，`n == 1, k == 1`是**基本情况**。而`k == 1`比较特殊，就以此为终止条件。

这里的错误是，终止条件应该为`k == 0`，不应该有`push_back`和`pop_back`。这个错误和第一个错误的是紧密联系的，实际上，终止条件执行的时候，`vec`不应该有任何增删操作，直接放进`res`就万事大吉了。

最开始还是`n == 4, k == 2`

如果是**遍历选取**，终止条件`k == 1`
```c++
for (int i = n; i >= 1; i--) {
    vec.push_back(i);
    combination(i - 1, k - 1, vec, res);
    vec.pop_back();
}
```
那么刚开始`i == 4`的时候，递归一下，`combination(3, 1, vec, res)`，因为`k`的位置为1，直接进入终止条件。递归后就不会再对2和1进行选取，最终就没有`[4, 2], [4, 1]`这两个组合，其他的类似。

然后我做了两个答案：

选或不选：
```c++
class Solution {
public:
    void combination(int n, int k, vector<int>& vec, vector<vector<int>>& res) {
        if (n < k && n == 0) return;
        if (k == 0) {
            res.push_back(vec);
            return;
        }
        vec.push_back(n);
        combination(n - 1, k - 1, vec, res);
        vec.pop_back();
        combination(n - 1, k, vec, res);
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> vec;
        combination(n, k, vec, res);
        return res;
    }
};
```

遍历选取：
```c++
class Solution {
public:
    void combination(int n, int k, vector<int>& vec, vector<vector<int>>& res) {
        if (n < k && n == 0) return;
        if (k == 0) {
            res.push_back(vec);
            return;
        }
        for (int i = n; i >= 1; i--) {
            vec.push_back(i);
            combination(i - 1, k - 1, vec, res);
            vec.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> vec;
        combination(n, k, vec, res);
        return res;
    }
};
```

选或不选的耗时和空间消耗都比较大，主要是因为会存在一直都不选的情况，这种情况是多于的，而遍历选取就没有这个问题。

下面这段代码值得注意。

因为我令`i = n`，而递归函数中`n`的位置为`i - 1`，这个过程隐含着去重。

如果是`i = 1`，那么递归函数要多添加一个`start`来记录上一个已经取到的元素，在`start + 1`的位置开始递归。
```c++
for (int i = n; i >= 1; i--) {
    vec.push_back(i);
    combination(i - 1, k - 1, vec, res);
    vec.pop_back();
}
```