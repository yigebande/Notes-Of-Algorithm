# 501. 二叉搜索树中的众数

又是没有思路的一道题，当然，哈希表＋数组的做法除外。

但是这是一棵二叉搜索树，肯定要利用其性质，然而正是要考虑利用BST的性质，我就没招了。

看了文章讲解做的答案。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int count = 0;
    int maxCount = 0;
    vector<int> res;
    TreeNode* prev = nullptr;
    void searchBST(TreeNode* root) {
        if (root == nullptr) return;
        searchBST(root->left);
        if (prev == nullptr) count = 1;
        else {
            if (prev->val == root->val) {
                count++;
            } else {
                count = 1;
            }
        }
        prev = root;
        if (count == maxCount) {
            res.push_back(root->val);
        } else if (count > maxCount) {
            maxCount = count;
            res.clear();
            res.push_back(root->val);
        }
        searchBST(root->right);
    }

public:
    vector<int> findMode(TreeNode* root) {
        searchBST(root);
        return res;
    }
};
```

## 一个新的发现

要利用BST的性质的时候，那就要用到中序遍历，就是对二叉树节点进行记录之类的操作是夹在`searchBST(root->left)`和`searchBST(root->right)`中间的。

即
```c++
searchBST(root->left);
// 记录等操作
searchBST(root->right);
```

## 题目思路
> 我是真的没想到会有`vector.clear()`这种操作

用`count`记录当前`root->val`**相同的值**的**出现次数**，用`maxCount`记录所遍历过节点中**众数**的。

用`prev`来记录上一个遍历过的点。

用`res`来记录遍历到当前节点时，所找到的全部众数。

题目说BST的节点的最少数量为1。

这里的`prev == nullptr`表示`prev`是开始遍历的第一个节点。
```c++
if (prev == nullptr) count = 1;
```

如果`prev != nullptr`，表明遍历至少已经到了第二个节点，那么这个时候就可以检查相邻遍历节点是否相同，如果相同，那么`count++`；如果不相同，那么`count = 1`，这里的`count`代表和`root->val`相同的元素的个数。

如果这个时候`count`和`maxCount`相等，那么说明这个可能是众数，先加入到`res`中去，否则`count > maxCount`的时候，新的“众数的个数”出现，前面加入到`res`的元素都要清空，清空完后要再次把`root->val`加进来。
> 在遍历的初期，可能会出现`res.clear()`经常执行的情况，因为`maxCount`有可能会一直递增。
```c++
if (count == maxCount) {
    res.push_back(root->val);
} else if (count > maxCount) {
    maxCount = count;
    res.clear();
    res.push_back(root->val);
}
```