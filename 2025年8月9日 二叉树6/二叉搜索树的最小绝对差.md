# 530. 二叉搜索树的最小绝对差

错误示例
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* first = nullptr;
    TreeNode* second = nullptr;
    int minimum;

    void traversal(TreeNode* root) {
        if (root == nullptr) return;
        if (first == nullptr) {
            traversal(root->left);
            first = root;
            traversal(root->right);
        } else if (second == nullptr) {
            traversal(root->left);
            second = root;
            minimum = second->val - first->val;
            cout << (second == nullptr) << endl;
            traversal(root->right);
        } else {
            traversal(root->left);
            first = second;
            second = root;
            cout << "first: " << first->val << endl;
            cout << "second: " << second->val << endl;
            if (minimum > second->val - first->val) minimum = second->val - first->val;
            traversal(root->right);
        }
    }

    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return minimum;
    }
};
```

以`first`的初始化为例，假设BST如下所示
```c++
if (first == nullptr) {
    traversal(root->left);
    first = root;
    traversal(root->right);
}
```

![](images/BST1.svg)

刚从根节点(10)进入递归的时候，`first == nullptr`成立，那么先执行第一句`traversal(root->left)`。

接下来到了节点(5)，`first == nullptr`依然成立，`traversal(root->left)`触发`root == nullptr`，所以这时候`first`被赋值为节点(5)，即`first->val == 5`。`traversal(root->right)`也触发`root == nullptr`。

那么现在回到节点(10)，还剩下
```c++
first = root;
traversal(root->right)
```
这两句

那么现在`first`又被赋值为节点(10)，即`first->val == 10`，刚刚的节点(5)的值就被抛弃了。

我刚刚还以为是指针传入函数传入的是副本（copy）的问题，但很显然我用的是全局变量，不会有副本的问题。

元宝给的正解，和文章讲解是一样的。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* prev = nullptr;
    int minimum = INT_MAX;

    void traversal(TreeNode* root) {
        if (root == nullptr) return;
        traversal(root->left);
        if (prev) {
            minimum = min(minimum, root->val - prev->val);
        }
        prev = root;
        traversal(root->right);
    }

    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return minimum;
    }
};
```

主要的难点在于如何记录前一个节点的值。

这里是在记录节点之前先进行最小值差的比较，然后再记录`root`。