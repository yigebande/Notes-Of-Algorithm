# 53. 最大子数组和
这里利用了买卖股票问题的思想。
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<vector<int>> dp(nums.size(), vector<int>(2, 0));
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][0] = max(nums[i], dp[i - 1][0] + nums[i]);
            res = max(res, max(dp[i][0], dp[i][1]));
        }
        return res;
    }
};
```

## 思路
1. `dp`数组下标含义
    `dp[i][0]`表示选择`nums[i]`为结尾的最大子数组和，`dp[i][1]`表示不选择`nums[i]`为结尾的最大子数组和。
2. 递推公式
    如果不选择`nums[i]`作为结尾，那么直接查看之前得到的最大子数组之和，即取`max(dp[i - 1][0], dp[i - 1][1])`

    如果选择`nums[i]`作为结尾，那么有两种可能：
    + 选择`nums[i - 1]`
    + 不选择`nums[i - 1]`，这会导致子数组不连续，应该以`nums[i]`为新的开头
3. 初始化
    因为选择的元素不能为空，也就是说至少得选择一个元素，所以`dp[0][0], dp[0][1]`都初始化为`nums[0]`。


## 节约空间的做法
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // vector<vector<int>> dp(nums.size(), vector<int>(2, 0));
        vector<int> dp(2, 0);
        dp[0] = nums[0];
        dp[1] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[1] = max(dp[0], dp[1]);
            dp[0] = max(nums[i], dp[0] + nums[i]);
            res = max(res, max(dp[0], dp[1]));
        }
        return res;
    }
};
```