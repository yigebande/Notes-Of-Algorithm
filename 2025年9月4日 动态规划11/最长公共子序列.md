# 1143. 最长公共子序列
和718. 最长重复子数组有点相同，但是这里是 **子序列** 的问题，是不一定连续的，而718. 是 **子数组** 的问题，是连续的。

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.length() + 1, vector<int>(text2.length() + 1, 0));
        int res = 0;
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};
```

## 思路
数组下标含义：长度为`i - 1`的`text1`的子串和长度为`j - 1`的`text2`的子串的最长公共子序列。

我是看的leetcode的提示做的，递推公式全给出来了。
```
DP[i][j] = DP[i - 1][j - 1] + 1, if text1[i] == text2[j]
DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]), otherwise
```

第一行比较好理解，就是如果`text1[i - 1] == text2[j - 1]`，那么回看长度为`i - 2`的`text1`和长度为`j - 2`的`text2`的最长公共子序列为多少，然后加一。

第二行很有意思，如果没有`text1[i] == text2[j]`，那么取`DP[i - 1][j], DP[i][j - 1]`的较大值。我的理解如下：
- `text1 = "abcde", text2 = "ace"`，那么有`text1[:3] = "abc", text2[:3] = "ace"`
- 此时`i == 3, j == 3`，没有`text1[i] == text2[j]`，我们可以看到这里的最长公共子序列为`"ac"`。没有`text1[i] == text2[j]`则表明有其中一个子串的新添加的一个字符是 **多余** 的，减去这一个字符所得到的新的子串的 **最长公共子序列** 和原来没有减去的是一样的。
- `dp[3][2] -> "abc" & "ac" ::: dp[2][3] -> "ab" & "ace"`