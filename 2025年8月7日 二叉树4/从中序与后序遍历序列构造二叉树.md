# 106. 从中序与后序遍历序列构造二叉树

做完了

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.empty() || postorder.empty()) return nullptr;
        // 提取postorder最后一个元素，即根节点的值
        int rootVal = postorder.back();
        // cout << root << endl;
        TreeNode* root = new TreeNode(rootVal);
        if (postorder.size() == 1) {
            return root;
        }
        // 在inorder中查找root的左树的长度
        int inorderLeftTreeSize = 0;
        for (int i = 0; i < inorder.size(); i++) {
            if (inorder[i] != rootVal) {
                inorderLeftTreeSize++;
            } else break;
        }
        // 构建root的左树的中序遍历
        vector<int> inorderLeftTree(inorder.begin(), inorder.begin() + inorderLeftTreeSize);
        // 构建root的右树的中序遍历
        vector<int> inorderRightTree(inorder.begin() + inorderLeftTreeSize + 1, inorder.end());
        // 构建root的左树的后序遍历
        vector<int> postorderLeftTree(postorder.begin(), postorder.begin() + 
                                                            inorderLeftTreeSize);
        // 构建root的右树的后序遍历
        vector<int> postorderRightTree(postorder.begin() + inorderLeftTreeSize, 
                                       postorder.end() - 1);
        root->left = buildTree(inorderLeftTree, postorderLeftTree);
        root->right = buildTree(inorderRightTree, postorderRightTree);
        return root;
    }
};
```

看了文章讲解后做的。

其实思路是很直观的。

1. 首先检查`inorder`和`postorder`是否为空，如果为空，表明已经遍历完毕，返回`nullptr`
2. `postorder`的最后一个元素就是当前树的根节点的值`root->val`，把这个值从`postorder`中提取出来。
3. 然后再在`inorder`中从头开始查找`root->val`对应的值，找到之后，所遍历过的元素全为左树的元素。这里我用`inorderLeftTreeSize`来记录左树元素子数组的长度（下面简称左树长度，右树同理）。在`inorder`和`postorder`中，左树长度和右树长度是分别相等的，这有利于分割`postorder`和`inorder`。
    ```c++
    int inorderLeftTreeSize = 0;
        for (int i = 0; i < inorder.size(); i++) {
            if (inorder[i] != rootVal) {
                inorderLeftTreeSize++;
            } else break;
        }
    ```

​   ![](images/inAndPost.svg)

4. 接下来是对`inorder`和`postorder`进行分割，分割要注意的点如下
   i. 左树和右树分别为空的情况
   ii. 迭代器是左闭右开区间的，使用`inorderLeftTreeSize`是否要`+1`？

5. 我尝试了一下`vector<int> vec(inorder.begin(), inorder.begin())`，然后发现`vec`是一个空的`vector`，`inorderLeftTreeSize`反映了左树的节点个数。

   所以这里对`inorder`进行左树的分割是合理的
   ```c++
   vector<int> inorderLeftTree(inorder.begin(), 
                               inorder.begin() + inorderLeftTreeSize);
   ```

   对`inorder`进行右树分割，由于左树末尾是根节点，所以对右树进行提取时要跳过这个根节点，即`inorderLeftTreeSize + 1`

   ```c++
    vector<int> inorderRightTree(
        inorder.begin() + inorderLeftTreeSize + 1, 
        inorder.end()
    );
   ```

    对`postorder`的左树右树提取的思路是类似的，这里不再赘述。

6. 最后就是对`root`的左右子节点进行递归处理。