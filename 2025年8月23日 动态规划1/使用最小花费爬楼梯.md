# 746. 使用最小花费爬楼梯

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1, 0);
        int size = cost.size();
        for (int i = 2; i <= size; i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[size];
    }
};
```

1. `dp`下标的含义为上到第`i`层楼梯所需要的最小花费
2. 递推式为`dp[i] = min(dp[i - 1] + cost[i - 1]), dp[i - 2] + cost[i - 2])`，如题目描述，从第`k`层往上走一层或者两层都是相同的花费`cost[k]`
3. 注意这里的循环条件为
```c++
for (int i = 2; i <= size; i++)
```
为什么是`i <= size`而不是`i < size`呢？

我是先测试了一遍`i < size`，发现最后`return`的结果都是少1或者少2，打印了一遍后才发现，走到`cost`的最后一个元素的时候，还要继续往后走，直到超过`cost`的大小才算上到顶层。

例如
```c++
cost = [1,100,100,1,1,100,1,1,1,1]

dp[2]: 1
dp[3]: 100
dp[4]: 101
dp[5]: 101
dp[6]: 102
dp[7]: 103
dp[8]: 103
dp[9]: 104
dp[10]: 104
```

`cost`的最大索引为9，从8到10或者从9到10才算真正走完。

我还想过一些特殊情形，比如`cost[0] == cost[1]`时，应该选择哪一个。

不过在这里每次迭代求到的结果是子问题的最优解，不用担心选择哪个会导致最后的结果不同。