# 198. 打家劫舍

我的代码：
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int maximum = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            if (i >= 2) {
                int tmp = nums[i];
                for (int j = i - 2; j >= 0; j--) {
                    nums[i] = max(tmp + nums[j], nums[i]);
                }
            }
            if (maximum < nums[i]) maximum = nums[i];
        }
        return maximum;
    }
};
```
我最开始的思路是，检查第`i`个`dp`的状态的时候，从`i - 2`的位置开始往前查找`tmp + nums[j]`的最大值。并且记录每次遍历得到的最大值`maximum`。

这里`dp[i]`表示偷当前房子的最大收益。

这样做的时间复杂度为$O(N^2)$。

看了文章讲解之后重新做了一遍：
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
};
```
这种处理的思路是，如果偷当前这家的总收益没有偷前一家的总收益多，那么直接继承偷前一家的状态。

因为并不是说，遍历到哪一家就必须要偷这一家。