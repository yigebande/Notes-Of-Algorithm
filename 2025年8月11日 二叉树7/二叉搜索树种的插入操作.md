# 701. 二叉搜索树中的插入操作

我用的是“尾插法”，感觉改动头节点太麻烦了，干脆在树的枝叶下功夫。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) return new TreeNode(val);
        if (root->left == nullptr && val < root->val) {
            root->left = new TreeNode(val);
        } else if (root->right == nullptr && val > root->val) {
            root->right = new TreeNode(val);
        }
        if (val < root->val) insertIntoBST(root->left, val);
        if (val > root->val) insertIntoBST(root->right, val);
        return root;
    }
};
```

这一句完全只适用于刚开始的根节点为空的情况。
```c++
if (root == nullptr) return new TreeNode(val);
```

如果根节点的左节点为空，并且`val < root->val`，就让这个空的左节点为`new TreeNode(val)`；右节点的情况类似。
```c++
if (root->left == nullptr && val < root->val) {
    root->left = new TreeNode(val);
} else if (root->right == nullptr && val > root->val) {
    root->right = new TreeNode(val);
}
```

如果`val < root->val`，但是左子节点不为空，那么肯定是进入下面这个`if`的；右子节点的情况类似。
```c++
if (val < root->val) insertIntoBST(root->left, val);
```

这里每一层递归都返回`root`，然而实际上只有要插入的时候才改变树的结构。