# 236. 二叉搜索树的最近公共祖先

按照二叉树的最近公共祖先的思路来做的

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == p || root == q || root == NULL) return root;
        TreeNode* checkp = p->val > root->val ? 
        lowestCommonAncestor(root->right, p, q) : lowestCommonAncestor(root->left, p, q);
        TreeNode* checkq = q->val > root->val ? 
        lowestCommonAncestor(root->right, p, q) : lowestCommonAncestor(root->left, p, q);
        if (checkp && checkq) {
            if (checkp == checkq) return checkp;
            else return root;
        }
        else if (checkp && !checkq) return checkp;
        else if (!checkp && checkq) return checkq;
        return NULL;
    }
};
```

首先检查`p->val`和`q->val`分别和`root->val`的大小关系。

`if (root == p || root == q || root == NULL) return root;`是基本情况，如果当前节点和`p`或者`q`相等，或者为空，那么返回当前节点。

下面的`checkp`的是根据`p->val`和`root->val`的相对大小来赋值的，这里利用了BST的性质，如果`p->val > root->val`，那么往根节点的右树搜索，否则往左树搜索（`checkq`同理）。
```c++
TreeNode* checkp = p->val > root->val ? 
lowestCommonAncestor(root->right, p, q) : lowestCommonAncestor(root->left, p, q);
```

要注意的一点是`checkp && checkq`需要分两种情况讨论
1. `checkp == checkq`，那么说明`checkp`是`p`和`q`的公共祖先，比`root`更近，那么应该返回`checkp`
1. `checkp != checkq`，说明`root`是两个节点的最近公共祖先，返回`root`
<br>

文章讲解的答案更加妙

只要判断`root->val`是否落在`[min(p, q), max(p, q)]`的区间里即可，否则就往下查找。

而且这里只需要搜索一条边，搜索到的第一个公共祖先就是最近公共祖先。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else if (root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else return root;
    }
};
```