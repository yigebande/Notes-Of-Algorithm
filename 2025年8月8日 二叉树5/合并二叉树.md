# 617. 合并二叉树

用了一些投机取巧的方法

```c++
在c++中，能否如下实现一个交换两个变量的值的函数？
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 合并节点到root1去
    void merge(TreeNode*& root1, TreeNode* root2) {
        if (root1 == nullptr && root2 == nullptr) return;
        else if (root1 != nullptr && root2 == nullptr) return;
        else if (root1 == nullptr && root2 != nullptr) 
        root1 = new TreeNode(root2->val, root2->left, root2->right);
        else {
            root1->val += root2->val;
            merge(root1->left, root2->left);
            merge(root1->right, root2->right);
        }
    }

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        merge(root1, root2);
        return root1;
    }
};
```

尤其注意这这里：
```c++
else if (root1 == nullptr && root2 != nullptr) 
root1 = new TreeNode(root2->val, root2->left, root2->right);
```

最开始我的`merge`是`merge(TreeNode* root1, TreeNode* root2)`，上面那行`root1`写的是
```c++
root1 = new TreeNode(root2->val)
```

但是最终并没有让`root1`变成新的节点。

我去问了豆包，豆包说C++中函数的传参是按照值传参的，`merge`传入的是`root1`的副本（copy），对副本进行修改不影响函数外部的变量，但是看起来矛盾的是，我后面试着去修改`root->left`的值，意外发现`root->left`是可以被修改的。

豆包给出的解释是，`root1->left`本质上是通过指针访问它所指向的对象的成员。

当你在函数中写 `root1->left = ...` 时，实际操作的是：

1. 通过函数内的指针副本 `root1_copy`，找到它所指向的节点（和原始指针 `root1` 指向的是同一个节点）。

2. 修改这个节点的 `left` 成员（一个指针）。

因为` root1_copy `和原始` root1 `指向**同一个节点**，所以修改这个节点的成员（`left` 或 `right`）会直接反映到原始指针所指向的节点上。因此，这种修改在函数外部是可见的。

**简单来说：**

1. 修改 `root1->left`：通过指针副本操作它指向的对象的成员，修改会影响外部（因为指向同一个对象）。
   
2. 修改 `root1`：直接修改指针副本本身的指向，修改不会影响外部的原始指针。

豆包建议我改成这样：
```c++
// 在root1前加一个引用&
void merge(TreeNode*& root1, TreeNode* root2)
```

我以前学过C，以为有了指针就能操作万物，然而这道题给我当头一棒，指针真的是一门很深奥的学问。